name: CI

on:
  push:
    tags: [ '*' ]

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout (with LFS)
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          fetch-depth: 0
          lfs: true

      - name: LFS ensure files present
        run: |
          git lfs install
          git lfs fetch --all
          git lfs checkout

      - name: Set up Flutter
        uses: subosito/flutter-action@fd55f4c5af5b953cc57a2be44cb082c8f6635e8e # v2.21.0
        with:
          flutter-version: '3.38.3'
          channel: 'stable'
          cache: true
          cache-key: 'flutter-sdk-3.38.3-stable-x64'
          pub-cache-key: 'flutter-pub-cache-v1'

      # - name: Verify Flutter installation
      #   run: flutter doctor -v

      # - name: Install dependencies
      #   run: make install

      # - name: Check localization files
      #   run: make check-l10n

      # - name: Verify code formatting
      #   run: make fmt-check

      # - name: Analyze code
      #   run: make analyze

      # - name: Check copyright headers
      #   run: make check-copyright

      - name: Extract version from pubspec.yaml
        run: |
          VERSION=$(grep '^version:' pubspec.yaml | sed 's/version:[[:space:]]*//' | cut -d+ -f1)
          echo "VERSION=${VERSION}" >> "$GITHUB_ENV"
          echo "Extracted version from pubspec.yaml: ${VERSION}"

      - name: Set up JDK 17
        uses: actions/setup-java@dded0888837ed1f317902acf8a20df0ad188d165 # v5.0.0
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Setup Android signing
        run: |
          # Get absolute path to workspace
          WORKSPACE_DIR="${{ github.workspace }}"
          KEYSTORE_PATH="${WORKSPACE_DIR}/.signing/release.keystore"
          
          # Create .signing directory
          mkdir -p .signing
          
          # Decode keystore from base64 secret (remove any whitespace/newlines)
          echo "${{ secrets.KEYSTORE_BASE64 }}" | tr -d '\n\r\t ' | base64 -d > "${KEYSTORE_PATH}"
          
          # Verify keystore file was created and has reasonable size
          if [ ! -f "${KEYSTORE_PATH}" ]; then
            echo "ERROR: Keystore file was not created at ${KEYSTORE_PATH}"
            exit 1
          fi
          
          KEYSTORE_SIZE=$(stat -f%z "${KEYSTORE_PATH}" 2>/dev/null || stat -c%s "${KEYSTORE_PATH}" 2>/dev/null)
          if [ "$KEYSTORE_SIZE" -lt 1000 ]; then
            echo "ERROR: Keystore file seems too small (${KEYSTORE_SIZE} bytes). Check KEYSTORE_BASE64 secret."
            exit 1
          fi
          
          # Verify secrets are not empty
          if [ -z "${{ secrets.KEY_STORE_PASSWORD }}" ] || [ -z "${{ secrets.KEY_PASSWORD }}" ] || [ -z "${{ secrets.KEY_ALIAS }}" ]; then
            echo "ERROR: One or more signing secrets are empty"
            exit 1
          fi
          
          # Create android/key.properties file with absolute path
          # Trim whitespace from secrets to avoid issues
          STORE_PASS=$(echo -n "${{ secrets.KEY_STORE_PASSWORD }}" | tr -d '\n\r\t ')
          KEY_PASS=$(echo -n "${{ secrets.KEY_PASSWORD }}" | tr -d '\n\r\t ')
          KEY_ALIAS=$(echo -n "${{ secrets.KEY_ALIAS }}" | tr -d '\n\r\t ')
          
          mkdir -p android
          cat > android/key.properties <<EOF
          storeFile=${KEYSTORE_PATH}
          storePassword=${STORE_PASS}
          keyPassword=${KEY_PASS}
          keyAlias=${KEY_ALIAS}
          EOF
          
          # Verify key.properties was created
          if [ ! -f android/key.properties ]; then
            echo "ERROR: key.properties file was not created"
            exit 1
          fi
          
          echo "âœ… Android signing configured"
          echo "   Keystore: ${KEYSTORE_PATH} (${KEYSTORE_SIZE} bytes)"
          echo "   Key properties: android/key.properties"
          echo "   Alias: ${KEY_ALIAS}"

      - name: Verify keystore before build
        run: |
          set +e  # Disable exit on error to capture keytool errors
          
          WORKSPACE_DIR="${{ github.workspace }}"
          KEYSTORE_PATH="${WORKSPACE_DIR}/.signing/release.keystore"
          
          # Trim whitespace from secrets (preserve special characters)
          STORE_PASS=$(printf '%s' "${{ secrets.KEY_STORE_PASSWORD }}" | tr -d '\n\r\t ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          KEY_PASS=$(printf '%s' "${{ secrets.KEY_PASSWORD }}" | tr -d '\n\r\t ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          KEY_ALIAS=$(printf '%s' "${{ secrets.KEY_ALIAS }}" | tr -d '\n\r\t ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          echo "ðŸ” Verifying keystore before build..."
          echo "   Keystore path: ${KEYSTORE_PATH}"
          echo "   Keystore exists: $([ -f "${KEYSTORE_PATH}" ] && echo 'yes' || echo 'no')"
          echo "   Alias: ${KEY_ALIAS}"
          echo "   Password length: ${#STORE_PASS} chars"
          
          # Check if keytool is available
          if ! command -v keytool &> /dev/null; then
            echo "âŒ ERROR: keytool is not available. Cannot verify keystore."
            exit 1
          fi
          
          # Step 1: Verify keystore password and list aliases
          echo ""
          echo "Step 1: Verifying keystore password..."
          KEYTOOL_OUTPUT=""
          KEYTOOL_EXIT_CODE=1
          
          # Try PKCS12 first (most common for modern keystores)
          KEYTOOL_OUTPUT=$(keytool -list -keystore "${KEYSTORE_PATH}" -storetype PKCS12 -storepass "${STORE_PASS}" 2>&1)
          KEYTOOL_EXIT_CODE=$?
          
          # If PKCS12 fails, try default type (JKS)
          if [ $KEYTOOL_EXIT_CODE -ne 0 ]; then
            echo "   PKCS12 failed, trying default storetype (JKS)..."
            KEYTOOL_OUTPUT=$(keytool -list -keystore "${KEYSTORE_PATH}" -storepass "${STORE_PASS}" 2>&1)
            KEYTOOL_EXIT_CODE=$?
          fi
          
          if [ $KEYTOOL_EXIT_CODE -ne 0 ]; then
            echo "âŒ ERROR: Keystore password verification failed"
            echo ""
            echo "   Full error output:"
            echo "$KEYTOOL_OUTPUT" | sed 's/^/     /'
            echo ""
            echo "   Troubleshooting:"
            echo "     - Check that KEY_STORE_PASSWORD secret matches the keystore password"
            echo "     - Ensure there are no extra spaces or newlines in the secret"
            echo "     - Verify the keystore file is not corrupted"
            set -e
            exit 1
          fi
          
          echo "âœ… Keystore password is correct"
          echo "   Available aliases:"
          echo "$KEYTOOL_OUTPUT" | grep -E '^[a-zA-Z0-9_-]+,' | sed 's/^/     /' || echo "$KEYTOOL_OUTPUT" | grep -i alias | sed 's/^/     /' || echo "     (Could not parse aliases)"
          
          # Step 2: Verify specific alias exists and key password
          echo ""
          echo "Step 2: Verifying alias '${KEY_ALIAS}' and key password..."
          KEYTOOL_ALIAS_OUTPUT=""
          KEYTOOL_ALIAS_EXIT_CODE=1
          
          # Try PKCS12 first
          KEYTOOL_ALIAS_OUTPUT=$(keytool -list -v -keystore "${KEYSTORE_PATH}" -storetype PKCS12 -storepass "${STORE_PASS}" -alias "${KEY_ALIAS}" -keypass "${KEY_PASS}" 2>&1)
          KEYTOOL_ALIAS_EXIT_CODE=$?
          
          # If PKCS12 fails, try default type
          if [ $KEYTOOL_ALIAS_EXIT_CODE -ne 0 ]; then
            KEYTOOL_ALIAS_OUTPUT=$(keytool -list -v -keystore "${KEYSTORE_PATH}" -storepass "${STORE_PASS}" -alias "${KEY_ALIAS}" -keypass "${KEY_PASS}" 2>&1)
            KEYTOOL_ALIAS_EXIT_CODE=$?
          fi
          
          if [ $KEYTOOL_ALIAS_EXIT_CODE -ne 0 ]; then
            echo "âŒ ERROR: Alias '${KEY_ALIAS}' or key password verification failed"
            echo ""
            echo "   Full error output:"
            echo "$KEYTOOL_ALIAS_OUTPUT" | sed 's/^/     /'
            echo ""
            echo "   Troubleshooting:"
            echo "     - Check that KEY_ALIAS secret matches an alias in the keystore (see aliases above)"
            echo "     - Check that KEY_PASSWORD secret matches the key password for this alias"
            echo "     - Ensure there are no extra spaces or newlines in the secrets"
            set -e
            exit 1
          fi
          
          echo "âœ… Alias '${KEY_ALIAS}' and key password are correct"
          
          # Step 3: Display certificate info
          echo ""
          echo "Step 3: Certificate information:"
          echo "$KEYTOOL_ALIAS_OUTPUT" | grep -E "(Owner:|Issuer:|Valid from)" | sed 's/^/     /' || true
          
          set -e  # Re-enable exit on error
          echo ""
          echo "âœ… Keystore verification completed successfully"
          echo "   Ready to proceed with build"

      - name: Build beta APK
        env:
          # Increase Gradle memory for CI builds
          GRADLE_OPTS: "-Xmx4g -XX:MaxMetaspaceSize=1g -XX:ReservedCodeCacheSize=1g"
        run: make build-android-beta-ci

      - name: Verify APK files exist
        id: verify-apk
        run: |
          # Check for APK files in both possible locations
          UNIVERSAL_APK=""
          SPLIT_APKS=""
          
          # Universal APK
          if [ -f "build/app/outputs/flutter-apk/app-beta-release.apk" ]; then
            UNIVERSAL_APK="build/app/outputs/flutter-apk/app-beta-release.apk"
          elif [ -f "build/app/outputs/apk/release/app-beta-release.apk" ]; then
            UNIVERSAL_APK="build/app/outputs/apk/release/app-beta-release.apk"
          fi
          
          # Split APKs
          for arch in arm64-v8a armeabi-v7a x86_64; do
            if [ -f "build/app/outputs/flutter-apk/app-${arch}-beta-release.apk" ]; then
              SPLIT_APKS="${SPLIT_APKS}build/app/outputs/flutter-apk/app-${arch}-beta-release.apk"$'\n'
            elif [ -f "build/app/outputs/apk/release/app-${arch}-beta-release.apk" ]; then
              SPLIT_APKS="${SPLIT_APKS}build/app/outputs/apk/release/app-${arch}-beta-release.apk"$'\n'
            fi
          done
          
          # Remove trailing newline
          SPLIT_APKS=$(echo "$SPLIT_APKS" | sed '/^$/d')
          
          # Combine all APKs
          ALL_APKS=""
          if [ -n "$UNIVERSAL_APK" ]; then
            ALL_APKS="${UNIVERSAL_APK}"$'\n'
          fi
          if [ -n "$SPLIT_APKS" ]; then
            ALL_APKS="${ALL_APKS}${SPLIT_APKS}"
          fi
          
          # Remove trailing newline
          ALL_APKS=$(echo "$ALL_APKS" | sed '/^$/d')
          
          if [ -z "$ALL_APKS" ]; then
            echo "âš ï¸  Warning: No APK files found!"
            echo "has_files=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Found APK files:"
            echo "$ALL_APKS"
            echo "has_files=true" >> $GITHUB_OUTPUT
            echo "files<<EOF" >> $GITHUB_OUTPUT
            echo "$ALL_APKS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog
        if: steps.verify-apk.outputs.has_files == 'true'
        run: make changelog

      # - name: Create GitHub Prerelease
      #   if: steps.verify-apk.outputs.has_files == 'true'
      #   id: release
      #   uses: softprops/action-gh-release@5be0e66d93ac7ed76da52eca8bb058f665c3a5fe # v2.4.2
      #   with:
      #     tag_name: ${{ github.ref_name }}
      #     name: Release ${{ env.VERSION }}-beta
      #     body_path: CHANGELOG.md
      #     draft: false
      #     prerelease: true
      #     files: ${{ steps.verify-apk.outputs.files }}
      #     fail_on_unmatched_files: false
      #     generate_release_notes: false
      #     make_latest: false